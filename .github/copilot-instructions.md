# Copilot Instructions
- Scope: Library for IIIF Presentation API 2.0 manifests using Newtonsoft.Json targeting netstandard2.0 and net451; core types live in src/IIIF.Manifest.Serializer.Net ([src/IIIF.Manifest.Serializer.Net/IIIF.Manifest.Serializer.Net.csproj](src/IIIF.Manifest.Serializer.Net/IIIF.Manifest.Serializer.Net.csproj)).
- Model layering: TrackableObject tracks ModifiedProperties and raises change events; BaseItem adds @context/@id/@type/service; BaseNode adds shared IIIF metadata (label, description, metadata, attribution, logo/thumbnail/license, seeAlso, within, related, viewingHint); BaseContent adds format and dimensions; BaseResource adds format-only resource support ([src/IIIF.Manifest.Serializer.Net/Shared](src/IIIF.Manifest.Serializer.Net/Shared)).
- Setter pattern: properties are private set; all mutation flows through SetPropertyValue/Attach/Detach helpers to keep ModifiedProperties consistent—follow this when adding setters or collections ([Shared/Trackable/TrackableObject.cs](src/IIIF.Manifest.Serializer.Net/Shared/Trackable/TrackableObject.cs), [Helpers/CollectionHelper.cs](src/IIIF.Manifest.Serializer.Net/Helpers/CollectionHelper.cs)).
- JSON converters: Every domain type has a custom JsonConverter that enforces required tokens and writes optional fields only when populated; they often accept single-or-array inputs and emit arrays when count > 1 ([Nodes/Manifest/ManifestJsonConverter.cs](src/IIIF.Manifest.Serializer.Net/Nodes/Manifest/ManifestJsonConverter.cs), [Shared/BaseNode/BaseNodeJsonConverter.cs](src/IIIF.Manifest.Serializer.Net/Shared/BaseNode/BaseNodeJsonConverter.cs)).
- Error handling: Missing/invalid JSON produces custom exceptions such as JsonNodeRequiredException<T>, JsonObjectMustBeJArray<T>, JsonObjectMustBeJObject<T>—match existing checks when extending converters ([Shared/Exceptions](src/IIIF.Manifest.Serializer.Net/Shared/Exceptions)).
- Manifest shape: Manifest → Sequence → Canvas → Image/OtherContent/EmbeddedContent/Segment; each level enforces required children (e.g., Manifest requires sequences, Sequence requires canvases, Canvas requires images/height/width) ([Nodes/Manifest/Manifest.cs](src/IIIF.Manifest.Serializer.Net/Nodes/Manifest/Manifest.cs), [Nodes/Sequence/Sequence.cs](src/IIIF.Manifest.Serializer.Net/Nodes/Sequence/Sequence.cs), [Nodes/Canvas/Canvas.cs](src/IIIF.Manifest.Serializer.Net/Nodes/Canvas/Canvas.cs)).
- Ranges/structures: Manifests may include structures (ranges) for navigation outlines; structures expect arrays for canvases/ranges and optional startCanvas with required @id. Use StructureJsonConverter validation patterns ([Nodes/Structure](src/IIIF.Manifest.Serializer.Net/Nodes/Structure)).
- Sequence startCanvas: Sequence supports an optional startCanvas reference; converter accepts object form and sets it via StartCanvas value object ([Nodes/Sequence](src/IIIF.Manifest.Serializer.Net/Nodes/Sequence)).
- Content/Resource pattern: Content annotations derive from BaseContent and may wrap a BaseResource subtype (ImageResource, EmbeddedContentResource, SegmentResource) that carries format/dimensions; converters require resource/on fields where applicable ([Shared/Content/BaseContent.cs](src/IIIF.Manifest.Serializer.Net/Shared/Content/BaseContent.cs), [Nodes/Content/Image](src/IIIF.Manifest.Serializer.Net/Nodes/Content/Image)).
- Dimension/viewing direction: Types implementing IDimenssionSupport or IViewingDirectionSupport should parse from JTokens via helper extension methods to stay consistent ([Properties/Interfaces](src/IIIF.Manifest.Serializer.Net/Properties/Interfaces)).
- Metadata/labels: Metadata aggregates MetadataValue objects with optional language; helper ManifestHelper.SetMetadata merges language-specific values instead of replacing wholesale ([Properties/Metadata](src/IIIF.Manifest.Serializer.Net/Properties/Metadata), [Helpers/ManifestHelper.cs](src/IIIF.Manifest.Serializer.Net/Helpers/ManifestHelper.cs)).
- Date parsing: navDate and similar fields parse ISO-8601 via DatetimeHelper.formats—add new formats there if parsing fails ([Helpers/DatetimeHelper.cs](src/IIIF.Manifest.Serializer.Net/Helpers/DatetimeHelper.cs)).
- Services: Service requires @context, @id, profile and supports tiles/dimensions; uses IDimenssionSupport helpers and TileJsonConverter for nested tiles ([Properties/Service](src/IIIF.Manifest.Serializer.Net/Properties/Service)).
- Tiles: Tile objects carry width and an array of scaleFactors; TileJsonConverter enforces array parsing and writes only populated fields ([Properties/Tile](src/IIIF.Manifest.Serializer.Net/Properties/Tile)).
- Rendering/SeeAlso/etc.: Small property wrappers often inherit FormatableItem or BaseItem with custom converters that disable type checking; follow existing inheritance to avoid double type validation ([Properties/Rendering/RenderingJsonConverter.cs](src/IIIF.Manifest.Serializer.Net/Properties/Rendering/RenderingJsonConverter.cs)).
- Serialization settings: TrackableObjectJsonConverter.WriteJson forces Formatting.Indented; converters clear ModifiedProperties after deserialization—do not add manual writes that bypass EnrichWriteJson hooks ([Shared/Trackable/TrackableObjectJsonConverter.cs](src/IIIF.Manifest.Serializer.Net/Shared/Trackable/TrackableObjectJsonConverter.cs)).
- Collection serialization: BaseNode/BaseContent converters emit single objects when count == 1 and arrays otherwise; maintain this behavior when adding new list properties to preserve backward compatibility.
- Required fields on construction: Many types lack parameterless constructors (e.g., Canvas needs id/label/height/width); deserialization constructors enforce presence of required tokens before instantiation—mirror this when adding fields.
- Sample usage: Round-trip benchmark lives in [src/IIIF.Manifest.Serializer.Net.Test/Program.cs](src/IIIF.Manifest.Serializer.Net.Test/Program.cs) using USA-congress-manifest.json; useful as smoke test after model changes.
- Build: `dotnet build IIIF.Manifest.Serializer.Net.sln` targets both frameworks; the console sample runs with `dotnet run --project src/IIIF.Manifest.Serializer.Net.Test` from repo root.
- Adding a new IIIF node/resource: derive from the closest base (BaseNode, BaseContent<T,TRes>, BaseResource), keep immutable public properties with private setters, expose fluent Set*/Add*/Remove* methods using Attach/Detach, implement a JsonConverter that (1) validates required tokens, (2) populates via helper extensions, (3) writes only populated fields.
- Adding new array-valued fields: prefer private List<T> with IReadOnlyCollection<T> public getter and Add/Remove methods calling SetPropertyValue to update ModifiedProperties and change notifications.
- Custom parsing: Use JsonHelper.TryGetToken for optional properties instead of direct indexers; ensure JArray/JObject checks before ToObject to align with existing error messaging.
- Formatting/format fields: For resources/content, set format through BaseContent/BaseResource SetFormat to keep converters consistent; avoid mutating Format directly.
- Context/type handling: BaseItemJsonConverter throws when @type missing unless DisableTypeChecking is set (e.g., FormatableItemJsonConverter); when introducing new converter, decide whether type validation is required.
- Multi-language strings: Description and MetadataValue support language tags; emit object with @value/@language only when language present, otherwise plain string—follow DescriptionJsonConverter/MetadataValueJsonConverter patterns.
- Within/SeeAlso arrays: BaseContentJsonConverter writes them as arrays unconditionally; if adding related link-like fields, align with this always-array behavior.
- Performance note: The sample benchmark measures deserialize/serialize times and diffs JSON; keep converters symmetric to avoid diff noise and maintain round-trip equality.
- If unsure where to add a field, check existing JSON property names constants to stay aligned with IIIF spec (e.g., HeightJName/WidthJName in [Shared/Constants.cs](src/IIIF.Manifest.Serializer.Net/Shared/Constants.cs)).
- Cookbook context: A common use case is a paged book-like object—sequence of Canvases each carrying a full-page image, labeled with human-friendly page/folio text, optionally with thumbnails for navigation. Behavior/viewingDirection hints affect page-turn UI; ensure "paged" or other hints are emitted when modeling books.
- IIIF v3 recipe awareness: The upstream cookbook example uses Presentation 3.0 (items/AnnotationPage/motivation painting). This library targets IIIF Presentation 2.0 (@id/@type, sequences/canvases/images). When porting recipes, map v3 concepts to v2 equivalents (items→sequences/canvases/images; body→resource; target→on) and keep labels multilingual.
- Simple single-image manifest: For the minimal case (one image + label), emit one Manifest with a single Canvas carrying height/width and one painting annotation linking the image as resource; map v3 AnnotationPage/Annotation/body/target to v2 sequence/canvas/image/on. Use language maps for labels even if only English.
- Segment/selectors: Segments require id/type/resource/on and may carry a selector for regions; default motivation is painting. Keep selector JSON objects intact and ensure resource/on are present during deserialization ([Nodes/Content/Segment](src/IIIF.Manifest.Serializer.Net/Nodes/Content/Segment)).
- Deep-zoom via IIIF Image API: To support zoom/derivatives, attach a IIIF Image service to the image resource (service array with id/base URI, type=ImageService{1|2|3}, profile level). In v2 mapping, this sits on the ImageResource’s service field; include dimensions and format, and optionally inline info.json (minus @context) for client optimization.
- Viewing direction: Only valid on Collection/Manifest/Range in IIIF; use ViewingDirection helpers (left-to-right default, right-to-left, top-to-bottom, bottom-to-top) and propagate to manifests/sequences/ranges as needed for navigation. In book flows combine with viewingHint/behavior (e.g., paged) and favor viewingDirection when ordering views.
- IIIF API landscape: iiif.io lists Presentation API stable at v3 and Image API stable at v3; this library targets Presentation 2.0. When following cookbook examples from iiif.io, map v3 fields to v2 equivalents (items→sequences/canvases/images, body→resource, target→on) and keep service type/profile consistent with the image API version you expose.
- Adjacent IIIF APIs: The ecosystem also includes Auth 2.0, Content Search 2.0, Change Discovery 1.0, and Content State 1.0. This library doesn’t implement them, but manifests may reference auth/search/discovery state; keep any such fields consistent with the target API versions if added.
